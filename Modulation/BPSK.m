clear, clc, close all; % все закрываем, очищаем консоль
fs = 10000; % частота дискретизации 10кГц
ts = 0: 1/fs: 0.1-1/fs; % массив временных отсчетов
N = length(ts); % количество отсчетов
fc = cos(2*pi*500*ts); % несущая частота
code = [1 1 -1 1 1 1 -1 -1 -1 1]; % единицу будет кодировать амплитуда равная 1, а 0 это -1
% поменять фазу на 180 град это умножить на -1
NF_bit = 100; % сколько отсчетов требуется для передачи одного бита
% тепеь задача раздвинуть code на всю несущую, чтобы 1 длился 100 тактов,
% -1 - 100 тактов и так далее
pm = repelem(code, NF_bit); 
% теперь задача сигнал смодулировать на всю частоту
subplot(2,1,1) 
plot(ts, fc), grid on;
subplot(2,1,2);
plot(pm), grid on
x = fc.*pm; % почленное произведение несущей частоты на сигнал фазовой модуляции, % теперь х - это смодулированный цифровой сигнал
% добавим шум, чтобы сымитировать неидельность условий
rng shuffle; % сделаем рандомайзер еще более рандомным 
x = x + (rand(1,N)*0.3-0.12);
figure
plot(ts, x), grid on, hold on; % фазово-модулированный сигнал
plot(ts, pm, 'LineWidth', 2); % цифровой сигнал 
h = hilbert(x); % получаем аналитиический сигнал
scatterplot(h, NF_bit, round(NF_bit/2)), grid on;
% точка на сигнальном созвездии это по сути 1 бит данных для передачи, разброс из-за шумов
y = x.*fc; % умножим почленно сигнал на несущую частоту
figure
plot(ts, y), grid on;
% получили сигнал, в котором уже можно различать логический 0 и логическую
% 1, для демодуляции используем ФНЧ
d_fir = bpsk_filter_lowpass;
% применим фильтр к нашему сигналу 
y_dem = filter(d_fir.Numerator, 1, y);
figure
plot(ts, y_dem), grid on;
figure
subplot(2,1,1);
plot(ts, y_dem), grid on;
d = y_dem>0.1; %если больше 0.1 значит логическая 1, меньше - 0
subplot(2,1,2);
plot(ts, d); grid on;

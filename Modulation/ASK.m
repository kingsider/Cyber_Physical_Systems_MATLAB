clear, clc, close all; % все закрываем, очищаем консоль
fs = 10000; % частота дискретизации 10кГц
ts = 0: 1/fs: 0.1-1/fs; % массив временных отсчетов
N = length(ts); % количество отсчетов

fc = cos(2*pi*1000*ts); % несущая частота

code = [1 1 0.1 1 1 1 0.1 0.1 0.1 1]; % единицу будет кодировать амплитуда равная 1, а 0 - 0.1
NF_bit = 100; % сколько отсчетов требуется для передачи одного бита

% теперь задача раздвинуть code на всю несущую, чтобы 1 длился 100 тактов,
% 0.1 - 100 тактов и так далее

s = repelem(code, NF_bit); 
% теперь задача сигнал смодулировать на всю частоту
subplot(2,1,1) 
plot(ts, fc), grid on; % сетка включена 
subplot(2,1,2);
plot(s), grid on; % сетка включена 

x = fc.*s; % почленное произведение несущей частоты на сигнал амплитудной модуляции, теперь х - это смодулированный цифровой сигнал

% добавим шум, чтобы сымитировать неидеальность условий
rng shuffle; % сделаем рандомайзер еще более рандомным 
x = x + (rand(1,N)*0.3-0.12); % добавим шум

figure
plot(ts, x), grid on, hold on; % амплитудно-модулированный сигнал
% теперь демодулируем 

h = hilbert(x); % получаем аналитический сигнал

scatterplot(h, NF_bit, round(NF_bit/2)), grid on;

% сигнальное созвездие round (NF_bit/2) - 
% смещение, как правило смещение ставим на середину бита
% точка на сигнальном созвездии это по сути 1 бит данных для передачи
% разброс из-за шумов
% сигнал вполне различим, и проблем при демодуляции быть не должно
% теперь делаем цифровой компаратор

ah = abs(h); % хранит амплитуду демодулированного сигнала
% получили огибающую
figure
subplot(2,1,1);
plot(ts, x), grid on, hold on;
plot(ts, ah); 

d = abs(h)>0.5; % если больше середины амплитуды значит 1, меньше 0
subplot(2,1,2);
plot(ts, d), grid on;
